<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSS的组件化VS原子化 | Wendy</title>
<link rel="shortcut icon" href="https://wendy-banzhuanke.github.io//favicon.ico?v=1655705991228">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://wendy-banzhuanke.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CSS的组件化VS原子化 | Wendy - Atom Feed" href="https://wendy-banzhuanke.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="大多数时候，CSS 就像 HTML 的一面镜子一样，嵌套的 CSS 选择器完美地映射了 HTML 结构。

一.组织和管理CSS
目录
1. BEM

BEM介绍
命名规范
BEM使用场景

2. ACSS

引入
原子化
相较于BEM的优..." />
    <meta name="keywords" content="css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://wendy-banzhuanke.github.io/">
  <img class="avatar" src="https://wendy-banzhuanke.github.io//images/avatar.png?v=1655705991228" alt="">
  </a>
  <h1 class="site-title">
    Wendy
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="/like" class="menu">
          随行
        </a>
      
    
      
        <a href="/add" class="menu">
          积累
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/wendy-banzhuanke" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CSS的组件化VS原子化
            </h2>
            <div class="post-info">
              <span>
                2019.10.17
              </span>
              <span>
                9 min read
              </span>
              
                <a href="https://wendy-banzhuanke.github.io/tag/TJdJomtu1/" class="post-tag">
                  # css
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>大多数时候，CSS 就像 HTML 的一面镜子一样，嵌套的 CSS 选择器完美地映射了 HTML 结构。</p>
<!-- more -->
<h2 id="一组织和管理css">一.组织和管理CSS</h2>
<h3 id="目录">目录</h3>
<h4 id="1-bem">1. BEM</h4>
<ul>
<li>BEM介绍</li>
<li>命名规范</li>
<li>BEM使用场景</li>
</ul>
<h4 id="2-acss">2. ACSS</h4>
<ul>
<li>引入</li>
<li>原子化</li>
<li>相较于BEM的优势</li>
<li>优缺点</li>
</ul>
<h3 id="说明">说明</h3>
<h4 id="1-bem-2">1. BEM</h4>
<p><strong>BEM 是什么</strong>？</p>
<p><a href="https://www.bemcss.com/">BEM</a> 其实就是块（block）、元素（element）、修饰符（modifier）的缩写。是由Yandex团队提出的一种前端命名方法论。利用不同的区块、功能以及样式给元素命名。</p>
<p><strong>命名规范</strong></p>
<p><img src="https://wendy-banzhuanke.github.io//post-images/1655704114163.png" alt="" loading="lazy"></br><br>
.block {} // 代表了更高级别的抽象或组件</br><br>
.block__element {} // 代表 block 的后代，用于形成一个完整的 block 的整体</br><br>
.block--modifier {} // 代表 block 的不同状态或不同版本</p>
<p>BEM的命名规范很容易记：block-name__element-name--modifier-name，也就是模块名 + 元素名 + 修饰器名。</p>
<blockquote>
<p>BEM 使用这种命名规范使代码更加易读，让代码更加严密，从而有助于协作、控制和维护。</p>
</blockquote>
<p>BEM命名方法：</p>
<pre><code class="language-html">&lt;div class=&quot;student&quot;&gt;
  &lt;div class=&quot;student__content&quot;&gt;
    &lt;button class=&quot;student__content--primary&quot;&gt;&lt;/button&gt;
    &lt;button class=&quot;student__content--success&quot;&gt;&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;

</code></pre>
<pre><code class="language-css">.student {}
.student__content{}
.student__content--primary{}
.student__content--success{}
</code></pre>
<p>一般的CSS命名：</p>
<pre><code class="language-html">&lt;div class=&quot;student&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    &lt;button class=&quot;button-primary&quot;&gt;&lt;/button&gt;
    &lt;button class=&quot;button-success&quot;&gt;&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">.student{}
.content{}
.button-primary{}
.button-success{}
</code></pre>
<blockquote>
<p>大多数时候，CSS 就像 HTML 的一面镜子一样，嵌套的 CSS 选择器完美地映射了 HTML 结构。</p>
</blockquote>
<p><strong>BEM使用场景</strong></p>
<ul>
<li>有比较明确的层级关系和组件关联的时候，需要使用 BEM</li>
<li>单条公共样式，不需要使用 BEM	.theme-red {color: red;}</li>
<li>header中的logo，其作用域是全局上下文 而非局部上下文，不需要使用BEM；一个元素的范围可能开始于任何上下文，因此要确定只在需要用到BEM的地方才使用它</li>
<li>预处理语言 + BEM</li>
<li>前端框架 + BEM</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://wendy-banzhuanke.github.io//post-images/1655704526102.png" alt="" loading="lazy"></figure>
<h4 id="2-acss-2">2. ACSS</h4>
<p>将样式原子化的思维方式，最早来自雅虎团队的 <a href="https://acss.io/">atomic css </a>（简称 ACSS ）。相较于上面介绍的BEM，ACSS 没有很严格的格式规范，但是它们解决的问题是一样的，都是希望 CSS 在大型项目下能够拥有更好的重用性与维护性，只是采用的方法与方向不同而已</p>
<ul>
<li><strong>引入</strong></li>
</ul>
<p>一件物品的属性可能是多种多样的，比如一件衬衫：颜色、尺寸、材料、花纹、品牌...我们同样可以将一个页面元素想象成一件衬衫，我们暂定一个完整的衬衫定义如下：</p>
<p>品牌 + 尺寸 + 颜色 + 花纹 + 季节 + 材料 + 样式</p>
<p>比如我要拿一件 李宁 L 码 黑色 带Logo 夏季 速干 短袖 衬衫，那么名字是不是写起来特别长？</p>
<p>但是我有时候又不需要所有的标签都需要带上，我可能只需要一件 XL码 白色 长袖 衬衫，然后我想给家人买一件 L 码 红色 纯棉 衬衫</p>
<p>这样不太好写一个可复用的 CSS 衬衫样式。</p>
<ul>
<li><strong>原子化</strong></li>
</ul>
<p>我们不要思考通过命名管理 CSS，而是将精力放在管理 CSS 的各种属性上，也就是构成我们衬衫的原子上，会不会更好呢？</p>
<p>比如我要一件衬衫，什么样子的我不清楚，当需求逐渐清晰的时候，再添加上各种属性：冷了就添加长袖，想舒服点就添加纯棉，骚了就添加夏威夷风，岂不美哉？</p>
<p>伪代码如下：</p>
<pre><code class="language-html">&lt;div class=&quot;XL码 白色 衬衫 长袖 纯棉 夏威夷风&quot;&gt;&lt;/div&gt;
</code></pre>
<p>ACSS 的原则是把 CSS 样式打散 不可再分的最小单位，每个 CSS 类只对应一条样式规则，从而达到最大化的可复用性。一个类只做一件事。yahoo 利用这种方案减轻了很多代码。</p>
<ul>
<li>
<p><strong>相较于BEM的优势</strong></p>
<ul>
<li>「BEM代码量过大」。可能会根据不同的组件设置不同的命名空间，很容易使得 CSS 层数过多，越是复杂的页面效果，层级越是容易多</li>
<li>「命名」。计算机科学中最难的两件事之一就是命名，而 Atomic CSS 直接舍弃了命名</li>
<li>「团队协作时的代码冗余」。几个团队协作的时候，更容易引发问题：</li>
</ul>
</li>
</ul>
<pre><code class="language-css">block1__text_highlight {color: yellow;} ​ 
... ​ 
block2__text_bright {color: yellow;}

</code></pre>
<p>显然，这种命名还不是拆分的最小单位，而 ACSS 是不可以拆分并且容易固化的，所以管理的难度会小很多，甚至随着需求的清晰，可以做到代码量的只增不减，并且复用率极高。</p>
<ul>
<li>
<p><strong>优缺点</strong></br></p>
<p><strong>列举一下优点</strong></p>
<ul>
<li>可复用性很强，将 class name 定义最小化，让全站都可复用</li>
<li>可组合性很强，这样任何页面都可以通过原子类的有机组合去实现</li>
<li>通过 atomic css 的打包，只会产生用到的样式</li>
<li>比起 inline 的方式更加简单</li>
<li>很好压缩，整体 size 小一点</li>
</ul>
<p><strong>当然也有缺点</strong></p>
<ul>
<li>写起来丑</li>
<li>没有语义化</li>
</ul>
</li>
</ul>
<blockquote>
<p>总的来说，acss是很值得你去尝试一种方式，熟练了之后会极大提高你的编码效率</p>
</blockquote>
<h2 id="二样式方案的四种粒度">二.样式方案的四种粒度</h2>
<p><strong>1. 第一种</strong></br></p>
<pre><code class="language-html">&lt;div style=&quot;{ borderRadius: '0.5rem', padding: '1rem' }&quot;&gt; Click &lt;/div&gt;
</code></pre>
<p>行内样式，众所周知，不利于复用, 选择什么值没有任何限制, 不利于规范约束（如：font-size:13px/14px）。</p>
<p><strong>2. 第二种</strong></br></p>
<pre><code class="language-html">&lt;div class=&quot;rounded-lg p-4 mr-2&quot;&gt; Click &lt;/div&gt;
</code></pre>
<p>原子化css, 将 class name 定义最小化，让全站都可复用, 体积小等， 优点很多，这两年很火的原子化CSS框架tailwindcss 还有高仿的windicss</p>
<pre><code class="language-css">.rounded-lg {
  border-radius:6px;
}
.p-4 {
  padding: 4px;
}
.mr-2 {
  margin-right:2px
}
.bg-blue-500 {
  background: #39be49;
}
</code></pre>
<p><strong>3. 第三种</strong></br></p>
<pre><code class="language-html">&lt;div class=&quot;button button--primary&quot;&gt; Click &lt;/div&gt;
</code></pre>
<p>这是css组件化的一种最普通的表现方式，组件化开发的一个优势，能够更快定位需要的地方。如下代码：</p>
<pre><code class="language-css">.button {
   display: inline-block;
   line-height: 1;
   min-height: 40px;
   white-space: nowrap;
   cursor: pointer;
   background: #fff;
   border: 1px solid #dcdfe6;
   color: #606266;
   text-align: center;
   box-sizing: border-box;
   outline: none;
   margin: 0;
   transition: .1s;
   font-weight: 500;
   padding: 12px 20px;
   font-size: 14px;
   border-radius: 4px;
}
.button--primary {
    color: #409eff;
    background: #ecf5ff;
    border-color: #b3d8ff;
}
</code></pre>
<blockquote>
<p>一个组件做的事情越多，或者一个组件越具体，就越难复用</br><br>
在 CSS 中采用组件优先的方法意味着你要为一些东西创建组件，即使它们永远不会被重复使用。这种过早的抽象是导致样式表臃肿和复杂的根源。</p>
</blockquote>
<p><strong>4. 第四种</strong></br></p>
<pre><code class="language-html">&lt;Button&gt; Click &lt;/Button&gt;
</code></pre>
<p>这也是强组件化css的一种方案，CSS-in-JS在React社区的热度是最高的，</p>
<p><mark>这四种方式越往下走，颗粒度越来越大，约束性变高，自由性不足。而 TailwindCSS 位于第二层，CSS in JS位于第四层。</mark></p>
<h2 id="三当前社区较火的框架">三.当前社区较火的框架</h2>
<h3 id="tailwind-css">Tailwind CSS</h3>
<h4 id="目录-2">目录</h4>
<ul>
<li>介绍</li>
<li>demo「演示本地项目，本地代码」</li>
<li>Tailwind JIT(V3.0)</li>
</ul>
<h4 id="说明-2">说明</h4>
<h5 id="1-介绍">1. 介绍</h5>
<p><a href="https://www.tailwindcss.cn/">tailwindcss</a>是一个Utility first的CSS框架，与以往我们重语义化的思想相悖，它的作者<a href="https://adamwathan.me/">Adam Wathan</a>是《Refactoring UI》这本书的作者</p>
<h5 id="2-demo">2. demo</h5>
<p>参考本地代码</p>
<h5 id="3-tailwind-jitv30">3. Tailwind JIT(V3.0)</h5>
<p>Tailwind CSS 作者 Adam Wathan 宣布了一个新项目：用于 Tailwind CSS 的 JIT 编译器 tailwindcss-jit，目前处于实验性阶段。</p>
<p>据介绍，tailwindcss-jit 会在开发者编写模板文件时按需编译所有 CSS，而不是预先生成整个样式表。</p>
<p>Tailwind CSS 作者提到了创建此项目的初衷，他表示这些年来在改进 Tailwind CSS 时，所处理的最困难的限制之一就是开发过程中生成的文件大小。只要对配置文件的定制足够深，生成的 CSS 大小会达到 10MB 或更多。而如此多的 CSS 又是构建工具或者浏览器所要求的。于是他便创建了此项目。</p>
<p>Tailwind CSS 作者还介绍了 tailwindcss-jit 的部分优点：</p>
<ul>
<li>构建速度极快</li>
<li>开箱即用地启用所有变体</li>
<li>无需编写自定义 CSS 即可生成任意样式</li>
<li>CSS 在开发和生产环境中保持一致</li>
<li>开发阶段提供更好的浏览器性能</li>
</ul>
<h3 id="css-in-js">CSS in JS</h3>
<p>一般软件开发都遵循关注点分离原则，css in js是关注点混合</p>
<h4 id="目录-3">目录</h4>
<ul>
<li>介绍</li>
<li>demo「演示本地项目，本地代码」</li>
</ul>
<h2 id="四结束">四.结束</h2>
<p>一般来说 组件化规范更适合基础组件库，关注点分离原则；<br>
原子化规范更适合业务布局开发，效率高，复用性高；</p>
<h3 id="推荐博文">推荐博文</h3>
<ol>
<li>https://adamwathan.me/css-utility-classes-and-separation-of-concerns/ (css功能类和关注点分离)</li>
</ol>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80%E7%BB%84%E7%BB%87%E5%92%8C%E7%AE%A1%E7%90%86css">一.组织和管理CSS</a>
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a>
<ul>
<li><a href="#1-bem">1. BEM</a></li>
<li><a href="#2-acss">2. ACSS</a></li>
</ul>
</li>
<li><a href="#%E8%AF%B4%E6%98%8E">说明</a>
<ul>
<li><a href="#1-bem-2">1. BEM</a></li>
<li><a href="#2-acss-2">2. ACSS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E6%A0%B7%E5%BC%8F%E6%96%B9%E6%A1%88%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B2%92%E5%BA%A6">二.样式方案的四种粒度</a></li>
<li><a href="#%E4%B8%89%E5%BD%93%E5%89%8D%E7%A4%BE%E5%8C%BA%E8%BE%83%E7%81%AB%E7%9A%84%E6%A1%86%E6%9E%B6">三.当前社区较火的框架</a>
<ul>
<li><a href="#tailwind-css">Tailwind CSS</a>
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95-2">目录</a></li>
<li><a href="#%E8%AF%B4%E6%98%8E-2">说明</a>
<ul>
<li><a href="#1-%E4%BB%8B%E7%BB%8D">1. 介绍</a></li>
<li><a href="#2-demo">2. demo</a></li>
<li><a href="#3-tailwind-jitv30">3. Tailwind JIT(V3.0)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#css-in-js">CSS in JS</a>
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95-3">目录</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E7%BB%93%E6%9D%9F">四.结束</a>
<ul>
<li><a href="#%E6%8E%A8%E8%8D%90%E5%8D%9A%E6%96%87">推荐博文</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://wendy-banzhuanke.github.io/post/javascript-jing-du-diu-shi-jie-xi/">
              <h3 class="post-title">
                JavaScript精度丢失解析
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://wendy-banzhuanke.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
